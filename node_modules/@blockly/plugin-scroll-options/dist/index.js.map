{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/plugin-scroll-options/webpack/universalModuleDefinition","webpack://@blockly/plugin-scroll-options/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/plugin-scroll-options/webpack/bootstrap","webpack://@blockly/plugin-scroll-options/webpack/runtime/compat get default export","webpack://@blockly/plugin-scroll-options/webpack/runtime/define property getters","webpack://@blockly/plugin-scroll-options/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/plugin-scroll-options/webpack/runtime/make namespace object","webpack://@blockly/plugin-scroll-options/./src/ScrollMetricsManager.js","webpack://@blockly/plugin-scroll-options/./src/utils.js","webpack://@blockly/plugin-scroll-options/./src/AutoScroll.js","webpack://@blockly/plugin-scroll-options/./src/ScrollBlockDragger.js","webpack://@blockly/plugin-scroll-options/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__573__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * The MetricsManager reports various metrics about the workspace. This version\n * of the MetricsManager adds optional cacheing of the workspace content\n * metrics. Cached content metrics are useful if, for example, you are in the\n * middle of dragging a block, but want to get the bounds of the content area as\n * if you hadn't yet picked up the block.\n *\n * To use the cached value of the content metrics instead of calculating new\n * ones, set `useCachedContentMetrics` to true before calling `getMetrics`\n * false when the metrics can be recalculated again.\n */\nexport class ScrollMetricsManager extends Blockly.MetricsManager {\n  /** @override */\n  constructor(workspace) {\n    super(workspace);\n\n    /**\n     * Whether to stop recalculating content metrics and used the cached value\n     * instead. Note that if there are no cached metrics, they will be\n     * recalculated even if this value is true.\n     * @type {boolean}\n     */\n    this.useCachedContentMetrics = false;\n\n    /**\n     * Cached content metrics, if available.\n     * @type {?Blockly.MetricsManager.ContainerRegion}\n     */\n    this.contentMetrics = null;\n  }\n\n  /** @override */\n  getContentMetrics() {\n    if (this.useCachedContentMetrics && this.contentMetrics) {\n      return this.contentMetrics;\n    }\n\n    this.contentMetrics = super.getContentMetrics();\n    return this.contentMetrics;\n  }\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Gets the current location of the workspace considering\n * when there's no drag surface.\n * @param {!Blockly.WorkspaceSvg} ws The workspace to calculate.\n * @returns {!Blockly.utils.Coordinate} The current workspace coordinate.\n */\nexport const getTranslation = (ws) => {\n  const dragSurface = ws.getBlockDragSurface();\n  if (dragSurface) {\n    return dragSurface.getWsTranslation();\n  } else {\n    const translation = ws.svgBlockCanvas_.getAttribute('transform');\n    const splitted = translation.split(',');\n    const x = Number(splitted[0].split('(')[1]);\n    const y = Number(splitted[1].split(')')[0]);\n    return new Blockly.utils.Coordinate(x, y);\n  }\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {ScrollMetricsManager} from './ScrollMetricsManager';\nimport {getTranslation} from './utils';\n\n/**\n * AutoScroll is used to scroll/pan the workspace automatically. For example,\n * when a user drags a block near the edge of the workspace, it can begin\n * automatically scrolling in that direction.\n *\n * Call `updateProperties` with a vector containing scroll velocity in each\n * direction, in pixels per ms. AutoScroll will use animation frames to smoothly\n * scroll the workspace at a constant velocity. Call `stopAndDestroy` to cancel\n * the AutoScroll animation. You must ensure this is called eventually, or you\n * may get stuck in an infinite animation loop and crash the browser.\n */\nexport class AutoScroll {\n  /**\n   * Creates an AutoScroll instance for a specified workspace.\n   * @param {!Blockly.WorkspaceSvg} workspace Workspace to scroll.\n   * @constructor\n   */\n  constructor(workspace) {\n    /**\n     * Workspace to scroll.\n     * @protected {!Blockly.WorkspaceSvg}\n     */\n    this.workspace_ = workspace;\n\n    /**\n     * Current active vector representing scroll velocity in pixels per\n     * millisecond in each direction.\n     * @protected {!Blockly.utils.Coordinate}\n     */\n    this.activeScrollVector_ = new Blockly.utils.Coordinate(0, 0);\n\n    /**\n     * ID of active requestAnimationFrame callback key.\n     * @type {number}\n     * @protected\n     */\n    this.animationFrameId_ = 0;\n\n    /**\n     * Time in ms last animation frame was run.\n     * @type {number}\n     * @protected\n     */\n    this.lastTime_ = Date.now();\n\n    /**\n     * Whether the scroll animation should continue. If this is false, the next\n     * animation frame will not be requested.\n     * @type {boolean}\n     * @protected\n     */\n    this.shouldAnimate_ = false;\n  }\n\n  /**\n   * Cancels the current autoscroll and resets properties.\n   */\n  stopAndDestroy() {\n    this.activeScrollVector_ = new Blockly.utils.Coordinate(0, 0);\n    this.shouldAnimate_ = false;\n    cancelAnimationFrame(this.animationFrameId_);\n    this.animationFrameId_ = 0;\n  }\n\n  /**\n   * Ticks scrolling behavior and triggers another\n   * frame request.\n   * @param {number} now Current time in ms. This is usually passed\n   *     automatically by `requestAnimationFrame`.\n   * @protected\n   */\n  nextAnimationStep_(now) {\n    if (this.shouldAnimate_) {\n      const delta = now - this.lastTime_;\n      this.lastTime_ = now;\n      // This method could be called multiple times per ms, and we only want to\n      // scroll if we should actually move.\n      if (delta > 0) {\n        this.scrollTick_(delta);\n      }\n\n      this.animationFrameId_ =\n          requestAnimationFrame((time) => this.nextAnimationStep_(time));\n    }\n  }\n\n  /**\n   * Perform scroll given time passed.\n   * @param {number} msPassed Number of ms since last scroll tick.\n   * @protected\n   */\n  scrollTick_(msPassed) {\n    const scrollDx = this.activeScrollVector_.x * msPassed;\n    const scrollDy = this.activeScrollVector_.y * msPassed;\n    this.scrollWorkspaceWithBlock(scrollDx, scrollDy);\n  }\n\n  /**\n   * Scrolls the workspace the given amount during a block drag.\n   * Also updates the dragger based on the amount actually scrolled.\n   * @param {number} scrollDx Amount to scroll in horizontal direction.\n   * @param {number} scrollDy Amount to scroll in vertical direction.\n   */\n  scrollWorkspaceWithBlock(scrollDx, scrollDy) {\n    const oldLocation = getTranslation(this.workspace_);\n\n    // As we scroll, we shouldn't expand past the content area that existed\n    // before the block was picked up. Therefore, we use cached ContentMetrics\n    // so that the content area does not change as we scroll.\n    const metricsManager =\n    /** @type {ScrollMetricsManager} */ (\n        this.workspace_.getMetricsManager());\n    metricsManager.useCachedContentMetrics = true;\n    const newX = this.workspace_.scrollX + scrollDx;\n    const newY = this.workspace_.scrollY + scrollDy;\n    this.workspace_.scroll(newX, newY);\n    metricsManager.useCachedContentMetrics = false;\n\n    const newLocation = getTranslation(this.workspace_);\n\n    // How much we actually ended up scrolling.\n    const deltaX = newLocation.x - oldLocation.x;\n    const deltaY = newLocation.y - oldLocation.y;\n\n    // If we did scroll, we need to let the dragger know by how much.\n    // The dragger will update its values so that things like connection\n    // markers will stay consistent.\n    if (deltaX || deltaY) {\n      this.workspace_.currentGesture_.getCurrentDragger()\n          .moveBlockWhileDragging(deltaX, deltaY);\n    }\n  }\n\n  /**\n   * Updates the scroll vector for the current autoscroll and begins the\n   * animation if needed.\n   * @param {!Blockly.utils.Coordinate} scrollVector New scroll velocity vector\n   *     in pixels per ms.\n   */\n  updateProperties(scrollVector) {\n    this.activeScrollVector_ = scrollVector;\n    this.shouldAnimate_ = true;\n\n    // Start new animation if there isn't one going.\n    if (this.animationFrameId_ == 0) {\n      this.lastTime_ = Date.now();\n      this.nextAnimationStep_(this.lastTime_);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview This adds a method to the block dragger to allow a block\n * to be moved when it is being dragged.\n */\n\nimport * as Blockly from 'blockly/core';\nimport {AutoScroll} from './AutoScroll';\n\n/**\n * @typedef {!Object<string, !Array<!Blockly.utils.Coordinate>>}\n */\nlet CandidateScrolls;\n\n/**\n * Configuration for edge scrolling behavior.\n * @typedef {object} EdgeScrollOptions\n * @property {number=} slowBlockSpeed Pixels per ms to scroll when the block is\n * near the edge of the workspace.\n * @property {number=}fastBlockSpeed Pixels per ms to scroll when the block is\n * far past the edge of the workspace.\n * @property {number=} slowBlockStartDistance Distance in workspace units that\n * the edge of the block is from the edge of the viewport before the\n * corresponding scroll speed will be used. Can be negative to start scrolling\n * before the block extends over the edge.\n * @property {number=} fastBlockStartDistance Same as above, for fast speed.\n * Must be larger than `slowBlockStartDistance`.\n * @property {number=} oversizeBlockThreshold If a block takes up this\n * percentage of the viewport or more, it will be considered oversized. Rather\n * than using the block edge, we use the mouse cursor plus the given margin size\n * to activate block-based scrolling.\n * @property {number=} oversizeBlockMargin Cursor margin to use for oversized\n * blocks. A bigger value will cause the workspace to scroll sooner, i.e., the\n * mouse can be further inward from the edge when scrolling begins.\n * @property {number=} slowMouseSpeed Pixels per ms to\n * scroll when the mouse is near the edge of the workspace.\n * @property {number=} fastMouseSpeed Pixels per ms to\n * scroll when the mouse is far past the edge of the workspace.\n * @property {number=} slowMouseStartDistance Distance in workspace units that\n * the mouse is from the edge of the viewport before the corresponding scroll\n * speed will be used. Can be negative to start scrolling before the mouse\n * extends over the edge.\n * @property {number=} fastMouseStartDistance Same as above, for fast speed.\n * Must be larger than `slowMouseStartDistance`.\n */\nexport let EdgeScrollOptions;\n\n/** @type {!EdgeScrollOptions} */\nconst defaultOptions = {\n  slowBlockSpeed: 0.28,\n  fastBlockSpeed: 1.4,\n  slowBlockStartDistance: 0,\n  fastBlockStartDistance: 50,\n  oversizeBlockThreshold: 0.85,\n  oversizeBlockMargin: 15,\n  slowMouseSpeed: 0.5,\n  fastMouseSpeed: 1.6,\n  slowMouseStartDistance: 0,\n  fastMouseStartDistance: 35,\n};\n\n/**\n * A block dragger that adds the functionality for a block to be moved while\n * someone is dragging it.\n */\nexport class ScrollBlockDragger extends Blockly.BlockDragger {\n  /** @override */\n  constructor(block, workspace) {\n    super(block, workspace);\n\n    /**\n     * How much the block has been moved due to scrolling.\n     * @type {!Blockly.utils.Coordinate}\n     * @protected\n     */\n    this.scrollDelta_ = new Blockly.utils.Coordinate(0, 0);\n\n    /**\n     * How much the block has been moved due to dragging.\n     * @type {!Blockly.utils.Coordinate}\n     * @protected\n     */\n    this.dragDelta_ = new Blockly.utils.Coordinate(0, 0);\n\n    // TODO(maribethb): Use `isMoveable` etc. to get this list\n    /**\n     * Possible directions the workspace could be scrolled.\n     * @type {!Array<string>}\n     * @protected\n     */\n    this.scrollDirections_ = ['top', 'bottom', 'left', 'right'];\n  }\n\n  /**\n   * Updates the location of the block that is being dragged.\n   * @param {number} deltaX Horizontal offset in pixel units.\n   * @param {number} deltaY Vertical offset in pixel units.\n   */\n  moveBlockWhileDragging(deltaX, deltaY) {\n    this.scrollDelta_.x -= deltaX;\n    this.scrollDelta_.y -= deltaY;\n\n    // The total amount the block has moved since being picked up.\n    const totalDelta =\n        Blockly.utils.Coordinate.sum(this.scrollDelta_, this.dragDelta_);\n\n    const delta = this.pixelsToWorkspaceUnits_(totalDelta);\n    const newLoc = Blockly.utils.Coordinate.sum(this.startXY_, delta);\n\n    // Make the block stay under the cursor.\n    this.draggingBlock_.moveDuringDrag(newLoc);\n\n    this.dragIcons_(totalDelta);\n\n    // As we scroll, show the insertion markers.\n    this.draggedConnectionManager_.update(\n        new Blockly.utils.Coordinate(\n            totalDelta.x / this.workspace_.scale,\n            totalDelta.y / this.workspace_.scale),\n        null);\n  }\n\n  /**\n   * Passes the total amount the block has moved (both from dragging and from\n   * scrolling) since it was picked up.\n   * @override\n   */\n  startDrag(currentDragDeltaXY, healStack) {\n    const totalDelta =\n        Blockly.utils.Coordinate.sum(this.scrollDelta_, currentDragDeltaXY);\n    super.startDrag(totalDelta, healStack);\n    this.dragDelta_ = currentDragDeltaXY;\n  }\n\n  /**\n   * Passes the total amount the block has moved (both from dragging and from\n   * scrolling) since it was picked up.\n   * @override\n   */\n  drag(e, currentDragDeltaXY) {\n    const totalDelta =\n        Blockly.utils.Coordinate.sum(this.scrollDelta_, currentDragDeltaXY);\n    super.drag(e, totalDelta);\n    this.dragDelta_ = currentDragDeltaXY;\n\n    if (ScrollBlockDragger.edgeScrollEnabled) {\n      this.scrollWorkspaceWhileDragging_(e);\n    }\n  }\n\n  /**\n   * @override\n   */\n  endDrag(e, currentDragDeltaXY) {\n    super.endDrag(e, currentDragDeltaXY);\n\n    this.stopAutoScrolling();\n  }\n\n  /**\n   * Passes the total amount the block has moved (both from dragging and from\n   * scrolling) since it was picked up.\n   * @override\n   */\n  getNewLocationAfterDrag_(currentDragDeltaXY) {\n    const newValues = {};\n    const totalDelta =\n        Blockly.utils.Coordinate.sum(this.scrollDelta_, currentDragDeltaXY);\n    newValues.delta = this.pixelsToWorkspaceUnits_(totalDelta);\n    newValues.newLocation =\n        Blockly.utils.Coordinate.sum(this.startXY_, newValues.delta);\n\n    return newValues;\n  }\n\n  /**\n   * May scroll the workspace as a block is dragged.\n   * If a block is dragged near the edge of the workspace, this method will\n   * cause the workspace to scroll in the direction the block is being\n   * dragged. The workspace will not resize as the block is dragged. The\n   * workspace should appear to move out from under the block, i.e., the block\n   * should stay under the user's mouse.\n   * @param {!Event} e The mouse/touch event for the drag.\n   * @protected\n   */\n  scrollWorkspaceWhileDragging_(e) {\n    /**\n     * Unit vector for each direction that could be scrolled. This vector will\n     * be scaled to get the calculated velocity in each direction. Must be a\n     * dict because the properties are accessed based on the members of\n     * `this.scrollDirections_`.\n     * @dict\n     * @private\n     */\n    this.SCROLL_DIRECTION_VECTORS_ = {\n      top: new Blockly.utils.Coordinate(0, 1),\n      bottom: new Blockly.utils.Coordinate(0, -1),\n      left: new Blockly.utils.Coordinate(1, 0),\n      right: new Blockly.utils.Coordinate(-1, 0),\n    };\n    const mouse = Blockly.utils.svgMath.screenToWsCoordinates(\n        this.workspace_, new Blockly.utils.Coordinate(e.clientX, e.clientY));\n\n    /**\n     * List of possible scrolls in each direction. This will be modified in\n     * place. Must be a dict because the properties are accessed based on the\n     * members of `this.scrollDirections_`.\n     * @dict\n     * @type {!CandidateScrolls}\n     */\n    const candidateScrolls = {\n      top: [],\n      bottom: [],\n      left: [],\n      right: [],\n    };\n\n    // Get ViewMetrics in workspace coordinates.\n    const viewMetrics =\n        this.workspace_.getMetricsManager().getViewMetrics(true);\n\n    // Get possible scroll velocities based on the location of both the block\n    // and the mouse.\n\n    this.computeBlockCandidateScrolls_(candidateScrolls, viewMetrics, mouse);\n    this.computeMouseCandidateScrolls_(candidateScrolls, viewMetrics, mouse);\n    // Calculate the final scroll vector we should actually use.\n    const overallScrollVector = this.getOverallScrollVector_(candidateScrolls);\n\n    // If the workspace should not be scrolled any longer, cancel the\n    // autoscroll.\n    if (Blockly.utils.Coordinate.equals(\n        overallScrollVector, new Blockly.utils.Coordinate(0, 0))) {\n      this.stopAutoScrolling();\n      return;\n    }\n\n    // Update the autoscroll or start a new one.\n    this.activeAutoScroll_ =\n        this.activeAutoScroll_ || new AutoScroll(this.workspace_);\n    this.activeAutoScroll_.updateProperties(overallScrollVector);\n  }\n\n  /**\n   * There could be multiple candidate scrolls for each direction, such as one\n   * for block position and one for mouse position. We should first find the\n   * fastest scroll in each direction. Then, we sum those to find the overall\n   * scroll vector.\n   *\n   * For example, we may have a fast block scroll and a slow\n   * mouse scroll candidate in both the top and left directions. First, we\n   * reduce to only the fast block scroll. Then, we sum the vectors in each\n   * direction to get a resulting fast scroll in a diagonal direction to the\n   * top left.\n   * @param {!CandidateScrolls} candidateScrolls Existing lists of candidate\n   *     scrolls. Will be modified in place.\n   * @returns {!Blockly.utils.Coordinate} Overall scroll vector.\n   * @protected\n   */\n  getOverallScrollVector_(candidateScrolls) {\n    let overallScrollVector = new Blockly.utils.Coordinate(0, 0);\n    for (const direction of this.scrollDirections_) {\n      const fastestScroll =\n          candidateScrolls[direction].reduce((fastest, current) => {\n            if (!fastest) {\n              return current;\n            }\n            return Blockly.utils.Coordinate.magnitude(fastest) >\n                    Blockly.utils.Coordinate.magnitude(current) ?\n                fastest :\n                current;\n          }, new Blockly.utils.Coordinate(0, 0)); // Initial value\n      overallScrollVector =\n          Blockly.utils.Coordinate.sum(overallScrollVector, fastestScroll);\n    }\n    return overallScrollVector;\n  }\n\n  /**\n   * Gets the candidate scrolls based on the position of the block on the\n   * workspace. If the block is near/over the edge, a candidate scroll will be\n   * added based on the options provided.\n   *\n   * This method can be overridden to further customize behavior, e.g. To add\n   * a third speed option.\n   * @param {!CandidateScrolls} candidateScrolls Existing list of candidate\n   *     scrolls. Will be modified in place.\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *     for the workspace.\n   * @param {!Blockly.utils.Coordinate} mouse Mouse coordinates.\n   * @protected\n   */\n  computeBlockCandidateScrolls_(candidateScrolls, viewMetrics, mouse) {\n    const blockOverflows = this.getBlockBoundsOverflows_(viewMetrics, mouse);\n    for (const direction of this.scrollDirections_) {\n      const overflow = blockOverflows[direction];\n      if (overflow > ScrollBlockDragger.options.slowBlockStartDistance) {\n        const speed =\n            overflow > ScrollBlockDragger.options.fastBlockStartDistance ?\n            ScrollBlockDragger.options.fastBlockSpeed :\n            ScrollBlockDragger.options.slowBlockSpeed;\n        const scrollVector =\n            this.SCROLL_DIRECTION_VECTORS_[direction].clone().scale(speed);\n        candidateScrolls[direction].push(scrollVector);\n      }\n    }\n  }\n\n  /**\n   * Gets the candidate scrolls based on the position of the mouse cursor\n   * relative to the workspace. If the mouse is near/over the edge, a\n   * candidate scroll will be added based on the options provided.\n   *\n   * This method can be overridden to further customize behavior, e.g. To add\n   * a third speed option.\n   * @param {!CandidateScrolls} candidateScrolls Existing list of candidate\n   *     scrolls. Will be modified in place.\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *     for the workspace.\n   * @param {!Blockly.utils.Coordinate} mouse Mouse coordinates.\n   * @protected\n   */\n  computeMouseCandidateScrolls_(candidateScrolls, viewMetrics, mouse) {\n    const mouseOverflows = this.getMouseOverflows_(viewMetrics, mouse);\n    for (const direction of this.scrollDirections_) {\n      const overflow = mouseOverflows[direction];\n      if (overflow > ScrollBlockDragger.options.slowMouseStartDistance) {\n        const speed =\n            overflow > ScrollBlockDragger.options.fastMouseStartDistance ?\n            ScrollBlockDragger.options.fastMouseSpeed :\n            ScrollBlockDragger.options.slowMouseSpeed;\n        const scrollVector =\n            this.SCROLL_DIRECTION_VECTORS_[direction].clone().scale(speed);\n        candidateScrolls[direction].push(scrollVector);\n      }\n    }\n  }\n\n  /**\n   * Gets the amount of overflow of a box relative to the workspace viewport.\n   *\n   * The value for each direction will be how far the given block edge is from\n   * the given edge of the viewport. If the block edge is outside the\n   * viewport, the value will be positive. If the block edge is inside the\n   * viewport, the value will be negative.\n   *\n   * This method also checks for oversized blocks. If the block is very large\n   * relative to the viewport size, then we will actually use a small zone\n   * around the cursor, rather than the edge of the block, to calculate the\n   * overflow values. This calculation is done independently in both the\n   * horizontal and vertical directions. These values can be configured in the\n   * options for the plugin.\n   *\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *     for the workspace.\n   * @param {!Blockly.utils.Coordinate} mouse Mouse coordinates.\n   * @returns {!Object<string, number>} An object describing the amount of\n   *     overflow in each direction.\n   * @protected\n   */\n  getBlockBoundsOverflows_(viewMetrics, mouse) {\n    const blockBounds = this.draggingBlock_.getBoundingRectangle();\n\n    // Handle large blocks. If the block is nearly as tall as the viewport,\n    // use a margin around the cursor rather than the height of the block.\n    const blockHeight = blockBounds.bottom - blockBounds.top;\n    if (blockHeight > viewMetrics.height *\n            ScrollBlockDragger.options.oversizeBlockThreshold) {\n      blockBounds.top = Math.max(\n          blockBounds.top,\n          mouse.y - ScrollBlockDragger.options.oversizeBlockMargin);\n      blockBounds.bottom = Math.min(\n          blockBounds.bottom,\n          mouse.y + ScrollBlockDragger.options.oversizeBlockMargin);\n    }\n\n    // Same logic, but for block width.\n    const blockWidth = blockBounds.right - blockBounds.left;\n    if (blockWidth > viewMetrics.width *\n            ScrollBlockDragger.options.oversizeBlockThreshold) {\n      blockBounds.left = Math.max(\n          blockBounds.left,\n          mouse.x - ScrollBlockDragger.options.oversizeBlockMargin);\n      blockBounds.right = Math.min(\n          blockBounds.right,\n          mouse.x + ScrollBlockDragger.options.oversizeBlockMargin);\n    }\n\n    // The coordinate system is negative in the top and left directions, and\n    // positive in the bottom and right directions. Therefore, the direction\n    // of the comparison must be switched for bottom and right.\n    return {\n      top: viewMetrics.top - blockBounds.top,\n      bottom: -(viewMetrics.top + viewMetrics.height - blockBounds.bottom),\n      left: viewMetrics.left - blockBounds.left,\n      right: -(viewMetrics.left + viewMetrics.width - blockBounds.right),\n    };\n  }\n\n  /**\n   * Gets the amount of overflow of the mouse coordinates relative to the\n   * viewport.\n   *\n   * The value for each direction will be how far the pointer is from\n   * the given edge of the viewport. If the pointer is outside the viewport,\n   * the value will be positive. If the pointer is inside the viewport, the\n   * value will be negative.\n   *\n   * @param {!Blockly.MetricsManager.ContainerRegion} viewMetrics View metrics\n   *     for the workspace.\n   * @param {!Blockly.utils.Coordinate} mouse Mouse coordinates.\n   * @returns {!Object<string, number>} An object describing the amount of\n   *     overflow in each direction.\n   * @protected\n   */\n  getMouseOverflows_(viewMetrics, mouse) {\n    // The coordinate system is negative in the top and left directions, and\n    // positive in the bottom and right directions. Therefore, the direction\n    // of the comparison must be switched for bottom and right.\n    return {\n      top: viewMetrics.top - mouse.y,\n      bottom: -(viewMetrics.top + viewMetrics.height - mouse.y),\n      left: viewMetrics.left - mouse.x,\n      right: -(viewMetrics.left + viewMetrics.width - mouse.x),\n    };\n  }\n\n  /**\n   * Cancel any AutoScroll. This must be called when there is no need to\n   * scroll further, e.g., when no longer dragging near the edge of the\n   * workspace, or when no longer dragging at all.\n   */\n  stopAutoScrolling() {\n    if (this.activeAutoScroll_) {\n      this.activeAutoScroll_.stopAndDestroy();\n    }\n    this.activeAutoScroll_ = null;\n  }\n}\n\n/**\n * Whether the behavior to scroll the workspace when a block is dragged near\n * the edge is enabled.\n * @type {boolean}\n */\nScrollBlockDragger.edgeScrollEnabled = true;\n\n/**\n * Configuration options for the scroll-options settings.\n * @type {!EdgeScrollOptions}\n */\nScrollBlockDragger.options = defaultOptions;\n\n/**\n * Update the scroll options. Only the properties actually included in the\n * `options` parameter will be set. Any unspecified options will use the\n * previously set value (where the initial value is from `defaultOptions`).\n * Therefore, do not pass in any options with explicit `undefined` or `null`\n * values. The plugin will break. Just leave them out of the object if you\n * don't want to change the default value.\n *\n * This method is safe to call multiple times. Subsequent calls will add onto\n * previous calls, not completely overwrite them. That is, if you call this\n * with:\n *\n *     `updateOptions({fastMouseSpeed: 5});\n *     updateOptions({slowMouseSpeed: 2});`.\n *\n * Then the final options used will include both `fastMouseSpeed: 5` and\n * `slowMouseSpeed: 2` with all other options being the default values.\n * @param {!EdgeScrollOptions} options Object containing any or all of\n *     the available options. Any properties not present will use the existing\n *     value.\n */\nScrollBlockDragger.updateOptions = function(options) {\n  ScrollBlockDragger.options = {...ScrollBlockDragger.options, ...options};\n};\n\n/**\n * Resets the options object to the default options.\n */\nScrollBlockDragger.resetOptions = function() {\n  ScrollBlockDragger.options = defaultOptions;\n};\n\nBlockly.registry.register(Blockly.registry.Type.BLOCK_DRAGGER,\n    'ScrollBlockDragger', ScrollBlockDragger);\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport Blockly from 'blockly/core';\nimport {EdgeScrollOptions, ScrollBlockDragger} from './ScrollBlockDragger';\nimport {getTranslation} from './utils';\n\n/**\n * A Blockly plugin that adds additional features related to scrolling and\n * dragging on workspaces. This plugin adds the ability to: a) use the\n * mousewheel to scroll the workspace while a block is being dragged, and b)\n * scroll the workspace automatically when a block is dragged near the edge.\n *\n * All behavior is customizable. See the README for more information.\n */\nexport class ScrollOptions {\n  /**\n   * Constructor for ScrollOptions plugin.\n   * @param {!Blockly.WorkspaceSvg} workspace The workspace that the plugin will\n   *     be added to.\n   */\n  constructor(workspace) {\n    /**\n     * The workspace.\n     * @type {!Blockly.WorkspaceSvg}\n     * @protected\n     */\n    this.workspace_ = workspace;\n  }\n\n  /**\n   * Initialize plugin with optional options. If no options are provided, both\n   * plugin features are enabled with default settings. The plugin is configured\n   * here as a convenience. See the README for more information on configuring\n   * the plugin after initialization.\n   * @param {{enableWheelScroll: (boolean|undefined),\n   * enableEdgeScroll: (boolean|undefined),\n   * edgeScrollOptions: (!EdgeScrollOptions|undefined)}=} options The\n   * configuration options for the plugin. `enableWheelScroll` and\n   * `enableEdgeScroll` are both true by default and control whether the\n   * behavior to scroll with the mouse wheel while dragging and scroll when a\n   * block is near the edge of the workspace are enabled, respectively.\n   * `edgeScrollOptions` is an optional configuration for the edge scrolling\n   * behavior. See `ScrollBlockDrager.updateOptions` for more details.\n   */\n  init({\n    enableWheelScroll = true,\n    enableEdgeScroll = true,\n    edgeScrollOptions = null,\n  } = {\n    enableWheelScroll: true,\n    enableEdgeScroll: true,\n    edgeScrollOptions: null,\n  }) {\n    if (enableWheelScroll) {\n      this.enableWheelScroll();\n    } else {\n      this.disableWheelScroll();\n    }\n\n    ScrollBlockDragger.edgeScrollEnabled = enableEdgeScroll;\n\n    if (edgeScrollOptions) {\n      ScrollBlockDragger.updateOptions(edgeScrollOptions);\n    }\n  }\n\n  /**\n   * Enables scrolling with mousewheel during block drag.\n   */\n  enableWheelScroll() {\n    if (this.wheelEvent_) {\n      // Already enabled.\n      return;\n    }\n\n    let element;\n    const dragSurface = this.workspace_.getBlockDragSurface();\n    if (dragSurface) {\n      element = dragSurface.getSvgRoot();\n    } else {\n      element = this.workspace_.svgGroup_;\n    }\n\n    this.wheelEvent_ = Blockly.browserEvents.conditionalBind(\n        element, 'wheel', this, this.onMouseWheel_);\n  }\n\n  /**\n   * Disables scrolling with mousewheel during block drag.\n   */\n  disableWheelScroll() {\n    if (!this.wheelEvent_) {\n      // Already disabled.\n      return;\n    }\n    Blockly.browserEvents.unbind(this.wheelEvent_);\n    this.wheelEvent_ = null;\n  }\n\n  /**\n   * Enables scrolling when block is dragged near edge.\n   */\n  enableEdgeScroll() {\n    ScrollBlockDragger.edgeScrollEnabled = true;\n  }\n\n  /**\n   * Disables scrolling when block is dragged near edge.\n   */\n  disableEdgeScroll() {\n    ScrollBlockDragger.edgeScrollEnabled = false;\n  }\n\n  /**\n   * Updates edge scroll options. See ScrollBlockDragger for specific settings.\n   * Any values left unspecified will not be overwritten and will retain their\n   * previous values.\n   * @param {!EdgeScrollOptions} options Edge scroll options.\n   */\n  updateEdgeScrollOptions(options) {\n    ScrollBlockDragger.updateOptions(options);\n  }\n\n  /**\n   * Scrolls the workspace with the mousewheel while a block is being dragged.\n   * Translates the currently dragged block as the user scrolls the workspace,\n   * so that the block does not appear to move.\n   * @param {!Event} e Mouse wheel event.\n   */\n  onMouseWheel_(e) {\n    const canWheelMove = this.workspace_.options.moveOptions &&\n        this.workspace_.options.moveOptions.wheel;\n    const currentGesture = this.workspace_.getGesture(e);\n\n    // Do not try to scroll if we are not dragging a block, or the workspace\n    // does not allow moving by wheel.\n    if (!canWheelMove || !currentGesture ||\n        !(currentGesture.getCurrentDragger() instanceof Blockly.BlockDragger)) {\n      return;\n    }\n\n    // Figure out the desired location to scroll to.\n    const scrollDelta = Blockly.browserEvents.getScrollDeltaPixels(e);\n    const x = this.workspace_.scrollX - scrollDelta.x;\n    const y = this.workspace_.scrollY - scrollDelta.y;\n\n    const oldLocation = getTranslation(this.workspace_);\n\n    // Try to scroll to the desired location.\n    this.workspace_.getMetricsManager().useCachedContentMetrics = true;\n    this.workspace_.scroll(x, y);\n    this.workspace_.getMetricsManager().useCachedContentMetrics = false;\n\n    const newLocation = getTranslation(this.workspace_);\n\n    // How much we actually ended up scrolling.\n    const deltaX = newLocation.x - oldLocation.x;\n    const deltaY = newLocation.y - oldLocation.y;\n\n    if (deltaX || deltaY) {\n      currentGesture.getCurrentDragger().moveBlockWhileDragging(deltaX, deltaY);\n      e.preventDefault();\n    }\n  }\n}\n\nexport * from './ScrollBlockDragger';\nexport * from './ScrollMetricsManager';\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","ScrollMetricsManager","workspace","useCachedContentMetrics","contentMetrics","Blockly","getTranslation","ws","dragSurface","getBlockDragSurface","getWsTranslation","splitted","svgBlockCanvas_","getAttribute","split","x","Number","y","utils","Coordinate","AutoScroll","workspace_","activeScrollVector_","animationFrameId_","lastTime_","Date","now","shouldAnimate_","cancelAnimationFrame","delta","scrollTick_","requestAnimationFrame","time","nextAnimationStep_","msPassed","scrollDx","scrollDy","scrollWorkspaceWithBlock","oldLocation","metricsManager","getMetricsManager","newX","scrollX","newY","scrollY","scroll","newLocation","deltaX","deltaY","currentGesture_","getCurrentDragger","moveBlockWhileDragging","scrollVector","defaultOptions","slowBlockSpeed","fastBlockSpeed","slowBlockStartDistance","fastBlockStartDistance","oversizeBlockThreshold","oversizeBlockMargin","slowMouseSpeed","fastMouseSpeed","slowMouseStartDistance","fastMouseStartDistance","ScrollBlockDragger","block","scrollDelta_","dragDelta_","scrollDirections_","totalDelta","pixelsToWorkspaceUnits_","newLoc","startXY_","draggingBlock_","moveDuringDrag","dragIcons_","draggedConnectionManager_","update","scale","currentDragDeltaXY","healStack","e","edgeScrollEnabled","scrollWorkspaceWhileDragging_","stopAutoScrolling","newValues","SCROLL_DIRECTION_VECTORS_","top","bottom","left","right","mouse","clientX","clientY","candidateScrolls","viewMetrics","getViewMetrics","computeBlockCandidateScrolls_","computeMouseCandidateScrolls_","overallScrollVector","getOverallScrollVector_","activeAutoScroll_","updateProperties","fastestScroll","reduce","fastest","current","blockOverflows","getBlockBoundsOverflows_","direction","overflow","options","speed","clone","push","mouseOverflows","getMouseOverflows_","blockBounds","getBoundingRectangle","height","Math","max","min","width","stopAndDestroy","updateOptions","resetOptions","ScrollOptions","enableWheelScroll","enableEdgeScroll","edgeScrollOptions","disableWheelScroll","wheelEvent_","element","getSvgRoot","svgGroup_","onMouseWheel_","canWheelMove","moveOptions","wheel","currentGesture","getGesture","scrollDelta","preventDefault"],"sourceRoot":""}