{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/block-dynamic-connection/webpack/universalModuleDefinition","webpack://@blockly/block-dynamic-connection/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/block-dynamic-connection/webpack/bootstrap","webpack://@blockly/block-dynamic-connection/webpack/runtime/define property getters","webpack://@blockly/block-dynamic-connection/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/block-dynamic-connection/webpack/runtime/make namespace object","webpack://@blockly/block-dynamic-connection/./src/insertion_marker_manager_monkey_patch.js","webpack://@blockly/block-dynamic-connection/./src/dynamic_if.js","webpack://@blockly/block-dynamic-connection/./src/dynamic_text_join.js","webpack://@blockly/block-dynamic-connection/./src/dynamic_list_create.js","webpack://@blockly/block-dynamic-connection/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__573__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Overrides methods on Blockly.InsertionMarkerManager to\n * allow blocks to hook in dynamic functionality when they have pending\n * connections.\n * @author anjali@code.org (Anjali Pal)\n */\n\nimport * as Blockly from 'blockly/core';\n\nBlockly.InsertionMarkerManager.prototype.update = function(dxy, dragTarget) {\n  const newCandidate = this.getCandidate(dxy);\n\n  this.wouldDeleteBlock = this.shouldDelete(!!newCandidate, dragTarget);\n\n  const shouldUpdate =\n      this.wouldDeleteBlock || this.shouldUpdatePreviews(newCandidate, dxy);\n\n  if (shouldUpdate) {\n    // Begin monkey patch\n    if (newCandidate &&\n        newCandidate.closest &&\n        newCandidate.closest.sourceBlock_.onPendingConnection) {\n      newCandidate.closest.sourceBlock_\n          .onPendingConnection(newCandidate.closest);\n      if (!this.pendingBlocks) {\n        this.pendingBlocks = new Set();\n      }\n      this.pendingBlocks.add(newCandidate.closest.sourceBlock_);\n    }\n    // End monkey patch\n    // Don't fire events for insertion marker creation or movement.\n    Blockly.Events.disable();\n    this.maybeHidePreview(newCandidate);\n    this.maybeShowPreview(newCandidate);\n    Blockly.Events.enable();\n  }\n};\n\nconst oldDispose = Blockly.InsertionMarkerManager.prototype.dispose;\nBlockly.InsertionMarkerManager.prototype.dispose = function() {\n  if (this.pendingBlocks) {\n    this.pendingBlocks.forEach((block) => {\n      if (block.finalizeConnections) {\n        block.finalizeConnections();\n      }\n    });\n  }\n  oldDispose.call(this);\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Defines a version of the if block with dyanmic\n *     inputs that appear when a block is dragged over inputs on the block.\n */\n\nimport * as Blockly from 'blockly/core';\n\nBlockly.Blocks['dynamic_if'] = {\n  /**\n   * Counter for the next input to add to this block.\n   * @type {number}\n   */\n  inputCounter: 1,\n\n  /**\n   * Minimum number of inputs for this block.\n   * @type {number}\n   */\n  minInputs: 1,\n\n  /**\n   * Block for if/elseif/else statements. Must have one if input.\n   * Can have any number of elseif inputs and optionally one else input.\n   * @this {Blockly.Block}\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg['CONTROLS_IF_HELPURL']);\n    this.setStyle('logic_blocks');\n\n    this.appendValueInput('IF0')\n        .setCheck('Boolean')\n        .appendField(Blockly.Msg['CONTROLS_IF_MSG_IF'], 'if');\n    this.appendStatementInput('DO0')\n        .appendField(Blockly.Msg['CONTROLS_IF_MSG_THEN']);\n\n    this.setNextStatement(true);\n    this.setPreviousStatement(true);\n    this.setTooltip(Blockly.Msg['LISTS_CREATE_WITH_TOOLTIP']);\n  },\n\n  /**\n   * Create XML to represent if/elseif/else inputs.\n   * @returns {!Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function() {\n    const container = Blockly.utils.xml.createElement('mutation');\n    const inputNames = this.inputList\n        .filter((input) => input.name.includes('IF'))\n        .map((input) => input.name.replace('IF', '')).join(',');\n    container.setAttribute('inputs', inputNames);\n    const hasElse = !!this.getInput('ELSE');\n    container.setAttribute('else', hasElse);\n    container.setAttribute('next', this.inputCounter);\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function(xmlElement) {\n    if (xmlElement.getAttribute('inputs')) {\n      this.deserializeInputs_(xmlElement);\n    } else {\n      this.deserializeCounts_(xmlElement);\n    }\n  },\n\n  /**\n   * Parses XML based on the 'inputs' attribute (non-standard).\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  deserializeInputs_: function(xmlElement) {\n    const inputs = xmlElement.getAttribute('inputs');\n    if (inputs) {\n      const inputNumbers = inputs.split(',');\n      if (this.getInput('IF0')) {\n        this.removeInput('IF0');\n      }\n      if (this.getInput('DO0')) {\n        this.removeInput('DO0');\n      }\n      const first = inputNumbers[0];\n      this.appendValueInput('IF' + first)\n          .setCheck('Boolean')\n          .appendField(Blockly.Msg['CONTROLS_IF_MSG_IF'], 'if');\n      this.appendStatementInput('DO' + first)\n          .appendField(Blockly.Msg['CONTROLS_IF_MSG_THEN']);\n\n      for (let i = 1; i < inputNumbers.length; i++) {\n        this.appendValueInput('IF' + inputNumbers[i])\n            .setCheck('Boolean')\n            .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSEIF'], 'elseif');\n        this.appendStatementInput('DO' + inputNumbers[i])\n            .appendField(Blockly.Msg['CONTROLS_IF_MSG_THEN']);\n      }\n    }\n    const hasElse = xmlElement.getAttribute('else');\n    if (hasElse == 'true') {\n      this.appendStatementInput('ELSE')\n          .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSE'], 'else');\n    }\n    const next = parseInt(xmlElement.getAttribute('next'));\n    this.inputCounter = next;\n  },\n\n  /**\n   * Parses XML based on the 'elseif' and 'else' attributes (standard).\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  deserializeCounts_: function(xmlElement) {\n    const elseifCount = parseInt(xmlElement.getAttribute('elseif'), 10) || 0;\n    const elseCount = parseInt(xmlElement.getAttribute('else'), 10) || 0;\n    for (let i = 1; i <= elseifCount; i++) {\n      this.appendValueInput('IF' + i).setCheck('Boolean').appendField(\n          Blockly.Msg['CONTROLS_IF_MSG_ELSEIF']);\n      this.appendStatementInput('DO' + i).appendField(\n          Blockly.Msg['CONTROLS_IF_MSG_THEN']);\n    }\n    if (elseCount) {\n      this.appendStatementInput('ELSE').appendField(\n          Blockly.Msg['CONTROLS_IF_MSG_ELSE']);\n    }\n    this.inputCounter = elseifCount + 1;\n  },\n\n  /**\n   * Finds the index of a connection. Used to determine where in the block to\n   * insert new inputs.\n   * @param {!Blockly.Connection} connection A connection on this block.\n   * @returns {?number} The index of the connection in the this.inputList.\n   */\n  findInputIndexForConnection: function(connection) {\n    for (let i = 0; i < this.inputList.length; i++) {\n      const input = this.inputList[i];\n      if (input.connection == connection) {\n        return i;\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Inserts a boolean value input and statement input at the specified index.\n   * @param {number} index Index of the input before which to add new inputs.\n   */\n  insertElseIf: function(index) {\n    const caseNumber = this.inputCounter;\n    this\n        .appendValueInput('IF' + caseNumber)\n        .setCheck('Boolean')\n        .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSEIF'], 'elseif');\n    this.appendStatementInput('DO' + caseNumber)\n        .appendField(Blockly.Msg['CONTROLS_IF_MSG_THEN']);\n    this.moveInputBefore('IF' + caseNumber, this.inputList[index].name);\n    this.moveInputBefore('DO' + caseNumber, this.inputList[index + 1].name);\n    this.inputCounter++;\n  },\n\n  /**\n   * Called when a block is dragged over one of the connections on this block.\n   * @param {!Blockly.Connection} connection The connection on this block that\n   * has a pending connection.\n   */\n  onPendingConnection: function(connection) {\n    if (connection.type === Blockly.NEXT_STATEMENT && !this.getInput('ELSE')) {\n      this.appendStatementInput('ELSE')\n          .appendField(Blockly.Msg['CONTROLS_IF_MSG_ELSE'], 'else');\n    }\n    const inputIndex = this.findInputIndexForConnection(connection);\n    if (inputIndex === null) {\n      return;\n    }\n    const input = this.inputList[inputIndex];\n    if (connection.targetConnection && input.name.includes('IF')) {\n      const nextIfInput = this.inputList[inputIndex + 2];\n      if (!nextIfInput || nextIfInput.name == 'ELSE') {\n        this.insertElseIf(inputIndex + 2);\n      } else {\n        const nextIfConnection = nextIfInput &&\n          nextIfInput.connection.targetConnection;\n        if (\n          nextIfConnection &&\n          !nextIfConnection.sourceBlock_.isInsertionMarker()\n        ) {\n          this.insertElseIf(inputIndex + 2);\n        }\n      }\n    }\n  },\n\n  /**\n   * Called when a block drag ends if the dragged block had a pending connection\n   * with this block.\n   */\n  finalizeConnections: function() {\n    const toRemove = [];\n    // Remove Else If inputs if neither the if nor the do has a connected block.\n    for (let i = 2; i < this.inputList.length - 1; i += 2) {\n      const ifConnection = this.inputList[i];\n      const doConnection = this.inputList[i + 1];\n      if (!ifConnection.connection.targetConnection &&\n          !doConnection.connection.targetConnection) {\n        toRemove.push(ifConnection.name);\n        toRemove.push(doConnection.name);\n      }\n    }\n    toRemove.forEach((input) => this.removeInput(input));\n\n    // Remove Else input if it doesn't have a connected block.\n    const elseInput = this.getInput('ELSE');\n    if (elseInput && !elseInput.connection.targetConnection) {\n      this.removeInput(elseInput.name);\n    }\n\n    // Remove the If input if it is empty and there is at least one Else If\n    if (this.inputList.length > 2) {\n      const ifInput = this.inputList[0];\n      const doInput = this.inputList[1];\n      const nextInput = this.inputList[2];\n      if (nextInput.name.includes('IF') &&\n          !ifInput.connection.targetConnection &&\n          !doInput.connection.targetConnection) {\n        this.removeInput(ifInput.name);\n        this.removeInput(doInput.name);\n        nextInput.removeField('elseif');\n        nextInput.appendField(Blockly.Msg['CONTROLS_IF_MSG_IF'], 'if');\n      }\n    }\n  },\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Defines a version of the text_join block with dyanmic\n *    inputs that appear when a block is dragged over inputs on the block.\n */\n\nimport * as Blockly from 'blockly/core';\n\nBlockly.Blocks['dynamic_text_join'] = {\n  /**\n   * Counter for the next input to add to this block.\n   * @type {number}\n   */\n  inputCounter: 2,\n\n  /**\n   * Minimum number of inputs for this block.\n   * @type {number}\n   */\n  minInputs: 2,\n\n  /**\n   * Block for concatenating any number of strings.\n   * @this {Blockly.Block}\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg['TEXT_JOIN_HELPURL']);\n    this.setStyle('text_blocks');\n    this.appendValueInput('ADD0')\n        .appendField(Blockly.Msg['TEXT_JOIN_TITLE_CREATEWITH']);\n    this.appendValueInput('ADD1');\n    this.setOutput(true, 'String');\n    this.setTooltip(Blockly.Msg['TEXT_JOIN_TOOLTIP']);\n  },\n\n  /**\n   * Create XML to represent number of text inputs.\n   * @returns {!Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function() {\n    const container = Blockly.utils.xml.createElement('mutation');\n    const inputNames = this.inputList.map((input) => input.name).join(',');\n    container.setAttribute('inputs', inputNames);\n    container.setAttribute('next', this.inputCounter);\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the text inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function(xmlElement) {\n    if (xmlElement.getAttribute('inputs')) {\n      this.deserializeInputs_(xmlElement);\n    } else {\n      this.deserializeCounts_(xmlElement);\n    }\n  },\n\n  /**\n   * Parses XML based on the 'inputs' attribute (non-standard).\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  deserializeInputs_: function(xmlElement) {\n    const items = xmlElement.getAttribute('inputs');\n    if (items) {\n      const inputNames = items.split(',');\n      this.inputList = [];\n      inputNames.forEach((name) => this.appendValueInput(name));\n      this.inputList[0]\n          .appendField(Blockly.Msg['TEXT_JOIN_TITLE_CREATEWITH']);\n    }\n    const next = parseInt(xmlElement.getAttribute('next'));\n    this.inputCounter = next;\n  },\n\n  /**\n   * Parses XML based on the 'items' attribute (standard).\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  deserializeCounts_: function(xmlElement) {\n    const itemCount = Math.max(\n        parseInt(xmlElement.getAttribute('items'), 10), this.minInputs);\n    // Two inputs are added automatically.\n    for (let i = this.minInputs; i < itemCount; i++) {\n      this.appendValueInput('ADD' + i);\n    }\n    this.inputCounter = itemCount;\n  },\n\n  /**\n   * Check whether a new input should be added and determine where it should go.\n   * @param {!Blockly.Connection} connection The connection that has a\n   *     pending connection.\n   * @returns {number} The index before which to insert a new input,\n   *     or null if no input should be added.\n   */\n  getIndexForNewInput: function(connection) {\n    if (!connection.targetConnection) {\n      // this connection is available\n      return null;\n    }\n\n    let connectionIndex;\n    for (let i = 0; i < this.inputList.length; i++) {\n      if (this.inputList[i].connection == connection) {\n        connectionIndex = i;\n      }\n    }\n\n    if (connectionIndex == this.inputList.length - 1) {\n      // this connection is the last one and already has a block in it, so\n      // we should add a new connection at the end.\n      return this.inputList.length + 1;\n    }\n\n    const nextInput = this.inputList[connectionIndex + 1];\n    const nextConnection = nextInput && nextInput.connection.targetConnection;\n    if (nextConnection && !nextConnection.sourceBlock_.isInsertionMarker()) {\n      return connectionIndex + 1;\n    }\n\n    // Don't add new connection\n    return null;\n  },\n\n  /**\n   * Called when a block is dragged over one of the connections on this block.\n   * @param {!Blockly.Connection} connection The connection on this block that\n   *     has a pending connection.\n   */\n  onPendingConnection: function(connection) {\n    const insertIndex = this.getIndexForNewInput(connection);\n    if (insertIndex == null) {\n      return;\n    }\n    this.appendValueInput('ADD' + (this.inputCounter++));\n    this.moveNumberedInputBefore(this.inputList.length - 1, insertIndex);\n  },\n\n  /**\n   * Called when a block drag ends if the dragged block had a pending connection\n   * with this block.\n   */\n  finalizeConnections: function() {\n    if (this.inputList.length > this.minInputs) {\n      let toRemove = [];\n      this.inputList.forEach((input) => {\n        const targetConnection = input.connection.targetConnection;\n        if (!targetConnection) {\n          toRemove.push(input.name);\n        }\n      });\n\n      if (this.inputList.length - toRemove.length < this.minInputs) {\n        // Always show at least two inputs\n        toRemove = toRemove.slice(this.minInputs);\n      }\n      toRemove.forEach((inputName) => this.removeInput(inputName));\n      // The first input should have the block text. If we removed the\n      // first input, add the block text to the new first input.\n      if (this.inputList[0].fieldRow.length == 0) {\n        this.inputList[0]\n            .appendField(Blockly.Msg['TEXT_JOIN_TITLE_CREATEWITH']);\n      }\n    }\n  },\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Defines a version of the list_create block with dyanmic\n *     inputs that appear when a block is dragged over inputs on the block.\n */\n\nimport * as Blockly from 'blockly/core';\n\nBlockly.Blocks['dynamic_list_create'] = {\n  /**\n   * Counter for the next input to add to this block.\n   * @type {number}\n   */\n  inputCounter: 2,\n\n  /**\n   * Minimum number of inputs for this block.\n   * @type {number}\n   */\n  minInputs: 2,\n\n  /**\n   * Block for concatenating any number of strings.\n   * @this {Blockly.Block}\n   */\n  init: function() {\n    this.setHelpUrl(Blockly.Msg['LISTS_CREATE_WITH_HELPURL']);\n    this.setStyle('list_blocks');\n    this.appendValueInput('ADD0')\n        .appendField(Blockly.Msg['LISTS_CREATE_WITH_INPUT_WITH']);\n    this.appendValueInput('ADD1');\n    this.setOutput(true, 'Array');\n    this.setTooltip(Blockly.Msg['LISTS_CREATE_WITH_TOOLTIP']);\n  },\n\n  /**\n   * Create XML to represent number of text inputs.\n   * @returns {!Element} XML storage element.\n   * @this {Blockly.Block}\n   */\n  mutationToDom: function() {\n    const container = Blockly.utils.xml.createElement('mutation');\n    const inputNames = this.inputList.map((input) => input.name).join(',');\n    container.setAttribute('inputs', inputNames);\n    container.setAttribute('next', this.inputCounter);\n    return container;\n  },\n\n  /**\n   * Parse XML to restore the text inputs.\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  domToMutation: function(xmlElement) {\n    if (xmlElement.getAttribute('inputs')) {\n      this.deserializeInputs_(xmlElement);\n    } else {\n      this.deserializeCounts_(xmlElement);\n    }\n  },\n\n  /**\n   * Parses XML based on the 'inputs' attribute (non-standard).\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  deserializeInputs_: function(xmlElement) {\n    const items = xmlElement.getAttribute('inputs');\n    if (items) {\n      const inputNames = items.split(',');\n      this.inputList = [];\n      inputNames.forEach((name) => this.appendValueInput(name));\n      this.inputList[0]\n          .appendField(Blockly.Msg['LISTS_CREATE_WITH_INPUT_WITH']);\n    }\n    const next = parseInt(xmlElement.getAttribute('next'));\n    this.inputCounter = next;\n  },\n\n  /**\n   * Parses XML based on the 'items' attribute (standard).\n   * @param {!Element} xmlElement XML storage element.\n   * @this {Blockly.Block}\n   */\n  deserializeCounts_: function(xmlElement) {\n    const itemCount = Math.max(\n        parseInt(xmlElement.getAttribute('items'), 10), this.minInputs);\n    // Two inputs are added automatically.\n    for (let i = this.minInputs; i < itemCount; i++) {\n      this.appendValueInput('ADD' + i);\n    }\n    this.inputCounter = itemCount;\n  },\n\n  /**\n   * Check whether a new input should be added and determine where it should go.\n   * @param {!Blockly.Connection} connection The connection that has a\n   *     pending connection.\n   * @returns {number} The index before which to insert a new input,\n   *     or null if no input should be added.\n   */\n  getIndexForNewInput: function(connection) {\n    if (!connection.targetConnection) {\n      // this connection is available\n      return null;\n    }\n\n    let connectionIndex;\n    for (let i = 0; i < this.inputList.length; i++) {\n      if (this.inputList[i].connection == connection) {\n        connectionIndex = i;\n      }\n    }\n\n    if (connectionIndex == this.inputList.length - 1) {\n      // this connection is the last one and already has a block in it, so\n      // we should add a new connection at the end.\n      return this.inputList.length + 1;\n    }\n\n    const nextInput = this.inputList[connectionIndex + 1];\n    const nextConnection = nextInput && nextInput.connection.targetConnection;\n    if (nextConnection && !nextConnection.sourceBlock_.isInsertionMarker()) {\n      return connectionIndex + 1;\n    }\n\n    // Don't add new connection\n    return null;\n  },\n\n  /**\n   * Called when a block is dragged over one of the connections on this block.\n   * @param {!Blockly.Connection} connection The connection on this block that\n   * has a pending connection.\n   */\n  onPendingConnection: function(connection) {\n    const insertIndex = this.getIndexForNewInput(connection);\n    if (insertIndex == null) {\n      return;\n    }\n    this.appendValueInput('ADD' + (this.inputCounter++));\n    this.moveNumberedInputBefore(this.inputList.length - 1, insertIndex);\n  },\n\n  /**\n   * Called when a block drag ends if the dragged block had a pending connection\n   * with this block.\n   */\n  finalizeConnections: function() {\n    if (this.inputList.length > this.minInputs) {\n      let toRemove = [];\n      this.inputList.forEach((input) => {\n        const targetConnection = input.connection.targetConnection;\n        if (!targetConnection) {\n          toRemove.push(input.name);\n        }\n      });\n\n      if (this.inputList.length - toRemove.length < this.minInputs) {\n        // Always show at least two inputs\n        toRemove = toRemove.slice(this.minInputs);\n      }\n      toRemove.forEach((inputName) => this.removeInput(inputName));\n      // The first input should have the block text. If we removed the\n      // first input, add the block text to the new first input.\n      if (this.inputList[0].fieldRow.length == 0) {\n        this.inputList[0]\n            .appendField(Blockly.Msg['LISTS_CREATE_WITH_INPUT_WITH']);\n      }\n    }\n  },\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Adds blocks that replace the built-in mutator UI with dynamic\n *     connections that appear when a block is dragged over inputs on the block.\n */\n\nimport * as Blockly from 'blockly/core';\nimport './insertion_marker_manager_monkey_patch';\nimport './dynamic_if.js';\nimport './dynamic_text_join.js';\nimport './dynamic_list_create.js';\n\nexport const overrideOldBlockDefinitions = function() {\n  Blockly.Blocks['lists_create_with'] = Blockly.Blocks['dynamic_list_create'];\n  Blockly.Blocks['text_join'] = Blockly.Blocks['dynamic_text_join'];\n  Blockly.Blocks['controls_if'] = Blockly.Blocks['dynamic_if'];\n};\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","Blockly","dxy","dragTarget","newCandidate","getCandidate","wouldDeleteBlock","shouldDelete","shouldUpdatePreviews","closest","sourceBlock_","onPendingConnection","pendingBlocks","Set","add","maybeHidePreview","maybeShowPreview","oldDispose","forEach","block","finalizeConnections","inputCounter","minInputs","init","setHelpUrl","setStyle","appendValueInput","setCheck","appendField","appendStatementInput","setNextStatement","setPreviousStatement","setTooltip","mutationToDom","container","inputNames","inputList","filter","input","name","includes","map","replace","join","setAttribute","hasElse","getInput","domToMutation","xmlElement","getAttribute","deserializeInputs_","deserializeCounts_","inputs","inputNumbers","split","removeInput","first","length","next","parseInt","elseifCount","elseCount","findInputIndexForConnection","connection","insertElseIf","index","caseNumber","moveInputBefore","type","inputIndex","targetConnection","nextIfInput","nextIfConnection","isInsertionMarker","toRemove","ifConnection","doConnection","push","elseInput","ifInput","doInput","nextInput","removeField","setOutput","items","itemCount","Math","max","getIndexForNewInput","connectionIndex","nextConnection","insertIndex","moveNumberedInputBefore","slice","inputName","fieldRow","overrideOldBlockDefinitions"],"sourceRoot":""}