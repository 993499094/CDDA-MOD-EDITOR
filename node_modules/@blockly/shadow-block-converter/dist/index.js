/*! For license information please see index.js.LICENSE.txt */
!function(e,o){if("object"==typeof exports&&"object"==typeof module)module.exports=o(require("blockly/core"));else if("function"==typeof define&&define.amd)define(["blockly/core"],o);else{var t="object"==typeof exports?o(require("blockly/core")):o(e.Blockly);for(var r in t)("object"==typeof exports?exports:e)[r]=t[r]}}(this,(e=>(()=>{"use strict";var o={573:o=>{o.exports=e}},t={};function r(e){var n=t[e];if(void 0!==n)return n.exports;var s=t[e]={exports:{}};return o[e](s,s.exports,r),s.exports}r.d=(e,o)=>{for(var t in o)r.o(o,t)&&!r.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:o[t]})},r.o=(e,o)=>Object.prototype.hasOwnProperty.call(e,o),r.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{r.r(n),r.d(n,{BlockShadowChange:()=>o,shadowBlockConversionChangeListener:()=>t});var e=r(573);class o extends e.Events.BlockBase{constructor(e,t,r){super(e),this.type=o.EVENT_TYPE,e&&(this.oldValue=void 0===t?"":t,this.newValue=void 0===r?"":r)}toJson(){const e=super.toJson();return e.oldValue=this.oldValue,e.newValue=this.newValue,e}fromJson(e){super.fromJson(e),this.oldValue=e.oldValue,this.newValue=e.newValue}isNull(){return this.oldValue===this.newValue}run(e){const o=this.getEventWorkspace_();if(!this.blockId)throw new Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");const t=o.getBlockById(this.blockId);if(!t)throw new Error("The associated block is undefined. Either pass a block to the constructor, or call fromJson");const r=e?this.newValue:this.oldValue;t.setShadow(!!r)}}function t(t){var r,n;if(!t.recordUndo)return;if(t.type!=e.Events.BLOCK_CHANGE)return;const s=t;if(!s.workspaceId||!s.blockId)return;const l=e.Workspace.getById(s.workspaceId);if(!l)return;const i=l.getBlockById(s.blockId);if(!i)return;if(!i.isShadow())return;const c=e.Events.getGroup();s.group?e.Events.setGroup(s.group):e.Events.setGroup(!0);const u=[i];for(let e=0;e<u.length;e++){const o=u[e],t=null===(r=o.outputConnection)||void 0===r?void 0:r.targetBlock(),s=null===(n=o.previousConnection)||void 0===n?void 0:n.targetBlock();(null==t?void 0:t.isShadow())&&u.push(t),(null==s?void 0:s.isShadow())&&u.push(s)}for(let t=u.length-1;t>=0;t--){const r=u[t];r.setShadow(!1),e.Events.fire(new o(r,!0,!1))}e.Events.setGroup(c)}o.EVENT_TYPE="block_shadow_change",e.registry.register(e.registry.Type.EVENT,o.EVENT_TYPE,o)})(),n})()));
//# sourceMappingURL=index.js.map