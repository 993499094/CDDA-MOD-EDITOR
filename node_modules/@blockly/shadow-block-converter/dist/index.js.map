{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/shadow-block-converter/webpack/universalModuleDefinition","webpack://@blockly/shadow-block-converter/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/shadow-block-converter/webpack/bootstrap","webpack://@blockly/shadow-block-converter/webpack/runtime/define property getters","webpack://@blockly/shadow-block-converter/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/shadow-block-converter/webpack/runtime/make namespace object","webpack://@blockly/shadow-block-converter/./src/shadow_block_converter.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__573__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__573__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @fileoverview Plugin for converting shadow blocks to real ones on edit.\n */\nimport * as Blockly from 'blockly/core';\n/**\n * A new blockly event class specifically for recording changes to the shadow\n * state of a block. This implementation is similar to and could be merged with\n * the implementation of Blockly.Events.BlockChange in Blockly core code.\n */\nexport class BlockShadowChange extends Blockly.Events.BlockBase {\n    /**\n     * The constructor for a new BlockShadowChange event.\n     * @param block The changed block. Undefined for a blank event.\n     * @param oldValue Previous value of shadow state.\n     * @param newValue New value of shadow state.\n     */\n    constructor(block, oldValue, newValue) {\n        super(block);\n        this.type = BlockShadowChange.EVENT_TYPE;\n        if (!block) {\n            return; // Blank event to be populated by fromJson.\n        }\n        this.oldValue = typeof oldValue === 'undefined' ? '' : oldValue;\n        this.newValue = typeof newValue === 'undefined' ? '' : newValue;\n    }\n    /**\n     * Encode the event as JSON.\n     * @returns JSON representation.\n     * @override\n     */\n    toJson() {\n        const json = super.toJson();\n        json['oldValue'] = this.oldValue;\n        json['newValue'] = this.newValue;\n        return json;\n    }\n    /**\n     * Decode the JSON event.\n     * @param json JSON representation.\n     * @override\n     */\n    fromJson(json) {\n        super.fromJson(json);\n        this.oldValue = json['oldValue'];\n        this.newValue = json['newValue'];\n    }\n    /**\n     * Does this event record any change of state?\n     * @returns False if something changed.\n     * @override\n     */\n    isNull() {\n        return this.oldValue === this.newValue;\n    }\n    /**\n     * Run a change event.\n     * @param forward True if run forward, false if run backward (undo).\n     * @override\n     */\n    run(forward) {\n        const workspace = this.getEventWorkspace_();\n        if (!this.blockId) {\n            throw new Error('The block ID is undefined. Either pass a block to ' +\n                'the constructor, or call fromJson');\n        }\n        const block = workspace.getBlockById(this.blockId);\n        if (!block) {\n            throw new Error('The associated block is undefined. Either pass a ' +\n                'block to the constructor, or call fromJson');\n        }\n        const value = forward ? this.newValue : this.oldValue;\n        block.setShadow(!!value);\n    }\n}\n/**\n * The name of the event type for broadcast and listening purposes.\n */\n/* eslint-disable @typescript-eslint/naming-convention */\nBlockShadowChange.EVENT_TYPE = 'block_shadow_change';\nBlockly.registry.register(Blockly.registry.Type.EVENT, BlockShadowChange.EVENT_TYPE, BlockShadowChange);\n/**\n * Add this function to your workspace as a change listener to automatically\n * convert shadow blocks to real blocks whenever the user edits a field on the\n * block, like this:\n *\n * workspace.addChangeListener(shadowBlockConversionChangeListener);\n *\n * Ideally the Blockly.Field.prototype.setValue method should handle this logic,\n * but for the purposes of this plugin it can be a workspace change listener.\n *\n * @param event An event broadcast by the workspace.\n */\nexport function shadowBlockConversionChangeListener(event) {\n    var _a, _b;\n    // Auto-converting shadow blocks to real blocks should happen in response to\n    // new user action events (which get recorded as undo events) but not when\n    // undoing or redoing events (which do not get recorded again).\n    if (!event.recordUndo) {\n        return;\n    }\n    // Auto-converting shadow blocks to real blocks should happen in response to\n    // editing a field value, which is recorded as Blockly.Events.BLOCK_CHANGE.\n    if (event.type != Blockly.Events.BLOCK_CHANGE) {\n        return;\n    }\n    const blockEvent = event;\n    if (!blockEvent.workspaceId || !blockEvent.blockId) {\n        return;\n    }\n    const workspace = Blockly.Workspace.getById(blockEvent.workspaceId);\n    if (!workspace) {\n        return;\n    }\n    const block = workspace.getBlockById(blockEvent.blockId);\n    if (!block) {\n        return;\n    }\n    // Blocks that are already real blocks can be ignored.\n    if (!block.isShadow()) {\n        return;\n    }\n    // Remember the current event group so that it can be resumed below.\n    const currentGroup = Blockly.Events.getGroup();\n    if (blockEvent.group) {\n        // Temporarily use the same group as the initiating event so that\n        // the shadow events get grouped with it for undo purposes.\n        Blockly.Events.setGroup(blockEvent.group);\n    }\n    else {\n        // The initiating event wasn't part of any named group, so the shadow events\n        // can't be grouped with it, but at least they can be grouped with each\n        // other.\n        Blockly.Events.setGroup(true);\n    }\n    // If the changed shadow block is a child of another shadow block, then both\n    // blocks should be converted to real blocks. To find all the shadow block\n    // ancestors that need to be converted to real blocks, seed the list of blocks\n    // starting with the changed block, and append all shadow block ancestors.\n    const shadowBlocks = [block];\n    for (let i = 0; i < shadowBlocks.length; i++) {\n        const shadowBlock = shadowBlocks[i];\n        // If connected blocks need to be converted too, add them to the list.\n        const outputBlock = (_a = shadowBlock.outputConnection) === null || _a === void 0 ? void 0 : _a.targetBlock();\n        const previousBlock = (_b = shadowBlock.previousConnection) === null || _b === void 0 ? void 0 : _b.targetBlock();\n        if (outputBlock === null || outputBlock === void 0 ? void 0 : outputBlock.isShadow()) {\n            shadowBlocks.push(outputBlock);\n        }\n        if (previousBlock === null || previousBlock === void 0 ? void 0 : previousBlock.isShadow()) {\n            shadowBlocks.push(previousBlock);\n        }\n    }\n    // The list of shadow blocks starts with the deepest child and ends with the\n    // highest parent, but the parent of a real block should never be a shadow\n    // block, so the parents need to be converted to real blocks first. Start\n    // at the end of the list and iterate backward to convert the blocks.\n    for (let i = shadowBlocks.length - 1; i >= 0; i--) {\n        const shadowBlock = shadowBlocks[i];\n        // Convert the shadow block to a real block and fire an event recording the\n        // change so that it can be undone. Ideally the\n        // Blockly.Block.prototype.setShadow method should fire this event directly,\n        // but for this plugin it needs to be explicitly fired here.\n        shadowBlock.setShadow(false);\n        Blockly.Events.fire(new BlockShadowChange(shadowBlock, true, false));\n    }\n    // Revert to the current event group, if any.\n    Blockly.Events.setGroup(currentGroup);\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__573__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","BlockShadowChange","constructor","block","oldValue","newValue","super","type","EVENT_TYPE","toJson","json","fromJson","isNull","run","forward","workspace","getEventWorkspace_","blockId","Error","getBlockById","setShadow","shadowBlockConversionChangeListener","event","_a","_b","recordUndo","blockEvent","workspaceId","isShadow","currentGroup","group","shadowBlocks","length","shadowBlock","outputBlock","outputConnection","targetBlock","previousBlock","previousConnection","push"],"sourceRoot":""}